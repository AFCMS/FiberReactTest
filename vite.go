// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package main

import "encoding/json"
import "fmt"

type Chunk struct {
	// Assets imported by the chunk.
	Assets []string `json:"assets,omitempty" yaml:"assets,omitempty" mapstructure:"assets,omitempty"`

	// CSS files imported by the chunk.
	Css []string `json:"css,omitempty" yaml:"css,omitempty" mapstructure:"css,omitempty"`

	// Dynamic imports of the chunk.
	DynamicImports []string `json:"dynamicImports,omitempty" yaml:"dynamicImports,omitempty" mapstructure:"dynamicImports,omitempty"`

	// A JS filename, relative to the outDir.
	File string `json:"file" yaml:"file" mapstructure:"file"`

	// Imports of the chunk.
	Imports []string `json:"imports,omitempty" yaml:"imports,omitempty" mapstructure:"imports,omitempty"`

	// Whether the chunk is a dynamic entry.
	IsDynamicEntry *bool `json:"isDynamicEntry,omitempty" yaml:"isDynamicEntry,omitempty" mapstructure:"isDynamicEntry,omitempty"`

	// Whether the chunk is an entry.
	IsEntry *bool `json:"isEntry,omitempty" yaml:"isEntry,omitempty" mapstructure:"isEntry,omitempty"`

	// Source file of the chunk.
	Src *string `json:"src,omitempty" yaml:"src,omitempty" mapstructure:"src,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *Chunk) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if v, ok := raw["file"]; !ok || v == nil {
		return fmt.Errorf("field file in Chunk: required")
	}
	type Plain Chunk
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = Chunk(plain)
	return nil
}

type ManifestSchemaJson map[string]interface{}
